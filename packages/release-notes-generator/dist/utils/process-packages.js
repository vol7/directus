"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processPackages = void 0;
const find_workspace_packages_1 = require("@pnpm/find-workspace-packages");
const workspace_pkgs_graph_1 = require("@pnpm/workspace.pkgs-graph");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const semver_1 = __importDefault(require("semver"));
const config_js_1 = __importDefault(require("../config.js"));
const sort_js_1 = require("./sort.js");
async function processPackages() {
    const workspacePackages = await (0, find_workspace_packages_1.findWorkspacePackagesNoCheck)(process.cwd());
    const packageVersions = new Map();
    let dependentsMap;
    for (const localPackage of workspacePackages) {
        const { name, version } = localPackage.manifest;
        if (!name) {
            continue;
        }
        const changelogPath = (0, node_path_1.join)(localPackage.dir, 'CHANGELOG.md');
        // The package has been bumped if a changelog file is generated
        // (catches packages bumped solely due to internal dependency updates from changesets too)
        if ((0, node_fs_1.existsSync)(changelogPath)) {
            if (version) {
                let finalVersion = version;
                // Reset 'version' field in private packages (falsely increased by changesets)
                if (localPackage.manifest.private) {
                    finalVersion = '0.0.0';
                    localPackage.manifest.version = finalVersion;
                    await localPackage.writeProjectManifest(localPackage.manifest);
                }
                packageVersions.set(name, finalVersion);
            }
            // Remove changelog files generated by changeset in favor of release notes
            (0, node_fs_1.unlinkSync)(changelogPath);
        }
    }
    const { mainVersion, manualMainVersion, isPrerelease, prereleaseId } = getVersionInfo();
    if (manualMainVersion) {
        await bumpPackage(config_js_1.default.mainPackage, mainVersion, true);
    }
    for (const [trigger, target] of config_js_1.default.linkedPackages) {
        if (packageVersions.has(trigger) && !packageVersions.has(target)) {
            await bumpPackage(target, null, true);
        }
    }
    return {
        mainVersion,
        isPrerelease,
        prereleaseId,
        packageVersions: Array.from(packageVersions, ([name, version]) => ({
            name,
            version,
        }))
            .filter(({ name }) => ![config_js_1.default.mainPackage, ...Object.keys(config_js_1.default.untypedPackageTitles)].includes(name))
            .sort((0, sort_js_1.sortByExternalOrder)(config_js_1.default.packageOrder, 'name')),
    };
    function getVersionInfo() {
        const manualMainVersion = process.env['DIRECTUS_VERSION'];
        const mainVersion = semver_1.default.parse(manualMainVersion ?? packageVersions.get(config_js_1.default.mainPackage));
        if (!mainVersion) {
            throw new Error(`Main version ('${config_js_1.default.mainPackage}' package) is missing or invalid`);
        }
        const isPrerelease = mainVersion.prerelease.length > 0;
        let prereleaseId;
        if (isPrerelease) {
            let tag;
            try {
                const changesetPreFile = (0, node_path_1.join)(process.cwd(), '.changeset', 'pre.json');
                ({ tag } = JSON.parse((0, node_fs_1.readFileSync)(changesetPreFile, 'utf8')));
            }
            catch {
                throw new Error(`Main version is a prerelease but changesets isn't in prerelease mode`);
            }
            prereleaseId = mainVersion.prerelease[0];
            if (typeof prereleaseId !== 'string') {
                throw new Error(`Expected a string for prerelease identifier`);
            }
            if (prereleaseId !== tag) {
                throw new Error(`Prerelease identifier of main version doesn't match tag of changesets prerelease mode`);
            }
        }
        return { mainVersion: mainVersion.version, manualMainVersion, isPrerelease, prereleaseId };
    }
    async function bumpPackage(packageName, version, bumpDependents) {
        const workspacePackage = workspacePackages.find((p) => p.manifest.name === packageName);
        if (!workspacePackage)
            return;
        let newVersion = null;
        if (version) {
            newVersion = version;
        }
        else if (workspacePackage.manifest.version) {
            newVersion = semver_1.default.inc(workspacePackage.manifest.version, isPrerelease ? 'prerelease' : 'patch', prereleaseId);
        }
        if (!newVersion)
            return;
        workspacePackage.manifest.version = newVersion;
        await workspacePackage.writeProjectManifest(workspacePackage.manifest);
        packageVersions.set(packageName, newVersion);
        if (bumpDependents) {
            const dependents = findDependents(packageName);
            for (const dependent of dependents) {
                if (!packageVersions.has(dependent))
                    await bumpPackage(dependent);
            }
        }
    }
    function getDependentsMap() {
        if (!dependentsMap) {
            const { graph } = (0, workspace_pkgs_graph_1.createPkgGraph)(workspacePackages);
            dependentsMap = transformGraph(graph);
        }
        return dependentsMap;
    }
    function findDependents(packageName, dependentsMap = getDependentsMap(), dependents = [], visited = new Set()) {
        if (visited.has(packageName))
            return dependents;
        visited.add(packageName);
        const packageDependents = dependentsMap[packageName];
        if (!packageDependents || packageDependents.length === 0)
            return dependents;
        for (const dependent of packageDependents) {
            if (visited.has(dependent))
                continue;
            dependents.push(dependent);
            findDependents(dependent, dependentsMap, dependents, visited);
        }
        return dependents;
    }
    function transformGraph(graph) {
        const dependentsMap = {};
        for (const dependentNodeId of Object.keys(graph)) {
            const dependentPackage = graph[dependentNodeId];
            const dependentPackageName = dependentPackage?.package.manifest.name;
            if (!dependentPackageName)
                continue;
            for (const dependencyNodeId of dependentPackage.dependencies) {
                const dependencyPackage = workspacePackages.find((p) => p.dir === dependencyNodeId);
                const dependencyPackageName = dependencyPackage?.manifest.name;
                if (!dependencyPackageName)
                    continue;
                if (!dependentsMap[dependencyPackageName]) {
                    dependentsMap[dependencyPackageName] = [dependentPackageName];
                }
                else {
                    dependentsMap[dependencyPackageName]?.push(dependentPackageName);
                }
            }
        }
        return dependentsMap;
    }
}
exports.processPackages = processPackages;
